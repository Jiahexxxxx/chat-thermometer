<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>èŠå¤©æº«åº¦è¨ˆ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body{font-family:system-ui,-apple-system;background:#0f172a;color:#e5e7eb;margin:0;display:flex;justify-content:center;padding:36px 14px}
    .card{width:100%;max-width:520px;background:#020617;border-radius:16px;padding:18px;box-shadow:0 18px 40px rgba(0,0,0,.45)}
    h1{text-align:center;margin:0 0 6px}
    .sub{text-align:center;opacity:.8;font-size:14px;margin-bottom:12px}
    input[type=file]{width:100%;padding:10px;border-radius:12px;background:#0b1220;border:1px solid rgba(255,255,255,.08);color:#e5e7eb;box-sizing:border-box}
    textarea{width:100%;height:90px;margin-top:10px;border-radius:12px;border:none;padding:10px;box-sizing:border-box;font-size:14px;outline:none}
    .preview{margin-top:10px;display:none;background:#0b1220;border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:10px}
    .preview img{width:100%;border-radius:10px;display:block}
    button{width:100%;margin-top:12px;padding:12px;border:none;border-radius:999px;background:#38bdf8;color:#020617;font-weight:800;font-size:16px}
    button:disabled{opacity:.6}
    .result{margin-top:14px;text-align:center;font-size:18px;min-height:28px}
    .hint{margin-top:8px;font-size:12px;opacity:.78;line-height:1.45}
    .crop{margin-top:10px}
    .crop label{display:block;font-size:12px;opacity:.85;margin-top:8px}
    .crop input{width:100%}
    .badge{display:inline-block;font-size:12px;padding:6px 10px;border-radius:999px;background:rgba(56,189,248,.14);border:1px solid rgba(56,189,248,.25);color:#cfefff}
  </style>
</head>
<body>
  <div class="card">
    <h1>èŠå¤©æº«åº¦è¨ˆ ğŸŒ¡ï¸</h1>
    <div class="sub">ä¸Šå‚³æˆªåœ–å¯è‡ªå‹•è¾¨è­˜ï½œä¹Ÿå¯ä»¥ç›´æ¥æ‰“å­—</div>

    <input id="image" type="file" accept="image/*" />

    <div class="preview" id="previewWrap">
      <img id="preview" alt="æˆªåœ–é è¦½" />
      <div class="hint"><span class="badge">âœ… å·²é¸æ“‡åœ–ç‰‡</span>ï¼ˆåœ–ç‰‡ä¸æœƒä¸Šå‚³åˆ°ä¼ºæœå™¨ï¼‰</div>
    </div>

    <div class="crop">
      <div class="hint">è£åˆ‡èŠå¤©å€ï¼ˆæå‡ä¸­æ–‡OCRæº–ç¢º / æ›´å¿«ï¼‰ï¼šå…ˆç”¨é è¨­ï¼Œä¸æº–å†èª¿</div>

      <label>ä¸Šæ–¹è£åˆ‡ï¼š<span id="ct">10</span>%</label>
      <input id="cropTop" type="range" min="0" max="30" value="10">

      <label>ä¸‹æ–¹è£åˆ‡ï¼š<span id="cb">8</span>%</label>
      <input id="cropBottom" type="range" min="0" max="30" value="8">

      <label>å·¦å³è£åˆ‡ï¼š<span id="cl">4</span>%</label>
      <input id="cropSide" type="range" min="0" max="15" value="4">
    </div>

    <textarea id="manualText" placeholder="ï¼ˆé¸å¡«ï¼‰ä½ ä¹Ÿå¯ä»¥ç›´æ¥æ‰“å¹¾å¥é‡é»ï¼Œä¾‹å¦‚ï¼šå¥¹å›å¾ˆæ…¢é‚„è¦èŠå—"></textarea>

    <button id="analyzeBtn" onclick="analyze()">é–‹å§‹åˆ†æ</button>

    <div class="result" id="result"></div>
    <div class="hint" id="statusHint"></div>
    <div class="hint" id="sourceHint"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <script>
    // ===== UI refs =====
    const imageInput = document.getElementById("image");
    const previewWrap = document.getElementById("previewWrap");
    const preview = document.getElementById("preview");
    const btn = document.getElementById("analyzeBtn");
    const resultDiv = document.getElementById("result");
    const statusHint = document.getElementById("statusHint");
    const sourceHint = document.getElementById("sourceHint");

    const cropTop = document.getElementById("cropTop");
    const cropBottom = document.getElementById("cropBottom");
    const cropSide = document.getElementById("cropSide");

    const ct = document.getElementById("ct");
    const cb = document.getElementById("cb");
    const cl = document.getElementById("cl");

    const manualTextEl = document.getElementById("manualText");

    let ocrText = "";
    let lastFile = null;

    // ===== slider display =====
    function syncSliders(){
      ct.textContent = cropTop.value;
      cb.textContent = cropBottom.value;
      cl.textContent = cropSide.value;
    }
    ["input","change"].forEach(ev=>{
      cropTop.addEventListener(ev, syncSliders);
      cropBottom.addEventListener(ev, syncSliders);
      cropSide.addEventListener(ev, syncSliders);
    });
    syncSliders();

    // ===== OCR workers (fast then best) =====
    let fastWorker = null;
    let bestWorker = null;

    async function ensureWorkers() {
      if (!fastWorker) {
        fastWorker = await Tesseract.createWorker("chi_tra+eng", 1, {
          langPath: "https://tessdata.projectnaptha.com/4.0.0_fast"
        });
      }
      if (!bestWorker) {
        bestWorker = await Tesseract.createWorker("chi_tra+eng", 1, {
          langPath: "https://tessdata.projectnaptha.com/4.0.0_best"
        });
      }
    }

    // ===== image preprocess: crop + scale + grayscale + contrast =====
    async function preprocessImageToBlob(file, scale = 2) {
      const topPct = (+cropTop.value)/100;
      const bottomPct = (+cropBottom.value)/100;
      const sidePct = (+cropSide.value)/100;

      const img = new Image();
      img.src = URL.createObjectURL(file);
      await new Promise((res, rej) => { img.onload = res; img.onerror = rej; });

      const sx = Math.floor(img.width * sidePct);
      const sy = Math.floor(img.height * topPct);
      const sw = Math.floor(img.width * (1 - sidePct * 2));
      const sh = Math.floor(img.height * (1 - topPct - bottomPct));

      const safeW = Math.max(80, sw);
      const safeH = Math.max(80, sh);

      const canvas = document.createElement("canvas");
      canvas.width = Math.floor(safeW * scale);
      canvas.height = Math.floor(safeH * scale);

      const ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(img, sx, sy, safeW, safeH, 0, 0, canvas.width, canvas.height);

      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const d = imageData.data;

      const contrast = 1.35;
      const intercept = 128 * (1 - contrast);

      for (let i = 0; i < d.length; i += 4) {
        const r = d[i], g = d[i+1], b = d[i+2];
        let v = 0.299*r + 0.587*g + 0.114*b;
        v = v * contrast + intercept;
        v = Math.max(0, Math.min(255, v));
        d[i] = d[i+1] = d[i+2] = v;
      }
      ctx.putImageData(imageData, 0, 0);

      return await new Promise(res => canvas.toBlob(res, "image/png"));
    }

    function cleanOcrText(raw) {
      if (!raw) return "";
      let t = raw.replace(/\r/g, "\n").replace(/[ \t]+/g, " ").replace(/\n{3,}/g, "\n\n").trim();
      t = t.replace(/[|Â¦Â·â€¢â—¦â—â– â–¡â—†â—‡]/g, "");
      const lines = t.split("\n").map(s => s.trim()).filter(Boolean);
      const kept = lines.filter(l => l.length >= 2);
      return kept.join("\n").trim();
    }

    function needBest(text) {
      if (!text) return true;
      const compactLen = text.replace(/\s/g, "").length;
      if (compactLen < 25) return true;
      const cjkCount = (text.match(/[\u4e00-\u9fff]/g) || []).length;
      if (cjkCount < 8) return true;
      const weird = (text.match(/[^\u4e00-\u9fffA-Za-z0-9ï¼Œã€‚ï¼ï¼Ÿï¼š()ã€Œã€ã€ã€\n ]/g) || []).length;
      const weirdRatio = weird / Math.max(1, compactLen);
      if (weirdRatio > 0.08) return true;
      return false;
    }

    async function runOcr(worker, blob, label) {
      await worker.setParameters({ tessedit_pageseg_mode: "6" });
      const { data } = await worker.recognize(blob, {
        logger: m => {
          if (m.status === "recognizing text") {
            const p = Math.round((m.progress || 0) * 100);
            statusHint.textContent = `${label}â€¦ ${p}%`;
          }
        }
      });
      return cleanOcrText(data.text);
    }

    // ===== source hint (photo/text) =====
    function updateSourceHint() {
      const typed = (manualTextEl.value || "").trim();
      const hasTyped = typed.length > 0;
      const hasOcr = (ocrText || "").trim().length > 0;

      if (!hasTyped && !hasOcr) {
        sourceHint.textContent = "ç›®å‰ï¼šå°šæœªè¼¸å…¥æ–‡å­—ï¼Œä¹Ÿæœªå®Œæˆæˆªåœ–è¾¨è­˜";
      } else if (hasTyped && hasOcr) {
        sourceHint.textContent = "ç›®å‰ï¼šâœ… ä½¿ç”¨ã€Œä½ è¼¸å…¥çš„æ–‡å­—ã€(å„ªå…ˆ)ï¼›æˆªåœ–è¾¨è­˜çµæœå·²å‚™ç”¨";
      } else if (hasTyped) {
        sourceHint.textContent = "ç›®å‰ï¼šâœ… ä½¿ç”¨ã€Œä½ è¼¸å…¥çš„æ–‡å­—ã€";
      } else {
        sourceHint.textContent = "ç›®å‰ï¼šâœ… ä½¿ç”¨ã€Œæˆªåœ–è¾¨è­˜æ–‡å­—ã€";
      }
    }

    manualTextEl.addEventListener("input", updateSourceHint);

    // ===== image upload => OCR automatically =====
    imageInput.addEventListener("change", async () => {
      const file = imageInput.files && imageInput.files[0];
      if (!file) return;

      lastFile = file;
      preview.src = URL.createObjectURL(file);
      previewWrap.style.display = "block";

      // start OCR status
      ocrText = "";
      updateSourceHint();
      resultDiv.textContent = "";
      statusHint.textContent = "ğŸ§  æ­£åœ¨è¾¨è­˜æˆªåœ–æ–‡å­—ï¼Œè«‹ç¨å€™â€¦";
      btn.disabled = true;

      try {
        // preprocess
        statusHint.textContent = "ğŸ§  æ­£åœ¨å¼·åŒ–æˆªåœ–æ¸…æ™°åº¦â€¦";
        const blob = await preprocessImageToBlob(file, 2);

        // ensure workers
        statusHint.textContent = "ğŸ§  è¼‰å…¥è¾¨è­˜å¼•æ“ï¼ˆç¬¬ä¸€æ¬¡è¼ƒä¹…ï¼‰â€¦";
        await ensureWorkers();

        // fast pass
        statusHint.textContent = "âš¡ å¿«é€Ÿè¾¨è­˜ä¸­â€¦ 0%";
        let text = await runOcr(fastWorker, blob, "âš¡ å¿«é€Ÿè¾¨è­˜ä¸­");

        // best if needed
        if (needBest(text)) {
          statusHint.textContent = "ğŸ¯ æ­£åœ¨æå‡ä¸­æ–‡æº–ç¢ºåº¦â€¦ 0%";
          text = await runOcr(bestWorker, blob, "ğŸ¯ æå‡ä¸­æ–‡æº–ç¢ºåº¦");
        }

        ocrText = (text || "").trim();
        if (!ocrText) {
          statusHint.textContent = "âŒ è¾¨è­˜ä¸åˆ°æ–‡å­—ï¼šè«‹æ›æ›´æ¸…æ¥šçš„æˆªåœ–ï¼ˆå­—æ›´å¤§ã€ä¸è¦å¤ªé•·ï¼‰ã€‚";
          btn.disabled = false;
          updateSourceHint();
          return;
        }

        statusHint.textContent = "âœ… è¾¨è­˜å®Œæˆï¼Œå¯ä»¥é–‹å§‹åˆ†æ";
        btn.disabled = false;
        updateSourceHint();
      } catch (e) {
        statusHint.textContent = "âŒ è¾¨è­˜å¤±æ•—ï¼Œè«‹æ›æ¸…æ¥šä¸€é»çš„æˆªåœ–æˆ–ç¨å¾Œå†è©¦";
        btn.disabled = false;
        updateSourceHint();
      }
    });

    // ===== analysis (typed first, else OCR) =====
    function analyze() {
      const typed = (manualTextEl.value || "").trim();
      const text = typed || ocrText;

      updateSourceHint();

      if (!text) {
        resultDiv.textContent = "è«‹ä¸Šå‚³æˆªåœ–æˆ–æ‰“å¹¾å¥æ–‡å­— ğŸ™‚";
        return;
      }

      let score = 0;
      const hot = ["æƒ³ä½ ","æŠ±","è¦ª","æ™šå®‰â¤ï¸","æ„›ä½ ","å–œæ­¡ä½ ","æƒ³è¦‹ä½ ","æƒ³è¦‹é¢","å¯¶","ğŸ˜˜","â¤ï¸"];
      const warm = ["å“ˆå“ˆ","æ€æ¨£","å¹¹å˜›","åœ¨å—","æ™šå®‰","å¯ä»¥","OK","å¥½å‘€","ç¬‘æ­»","æ€éº¼äº†"];
      const cold = ["å›å¾ˆæ…¢","å·²è®€ä¸å›","éƒ½æˆ‘ä¸»å‹•","ä¸å›","æ•·è¡","å—¯","å“¦","å¥½","éš¨ä¾¿"];

      hot.forEach(w => { if (text.includes(w)) score += 2; });
      warm.forEach(w => { if (text.includes(w)) score += 1; });
      cold.forEach(w => { if (text.includes(w)) score -= 1; });

      let label = "â„ï¸ åå†·";
      if (score >= 5) label = "ğŸ”¥ å¾ˆç†±";
      else if (score >= 3) label = "ğŸŒ¤ï¸ æ›–æ˜§";
      else if (score >= 1) label = "ğŸ™‚ æ™®é€š";

      resultDiv.textContent = label;
    }

    // init hints
    updateSourceHint();
  </script>
</body>
</html>
